#!/usr/bin/env ruby

golden_tags = IO.read(ARGV[0]).split("\n")
result_tags = IO.read(ARGV[1]).split("\n")
if golden_tags.length != result_tags.length
  exit 1
end

tag2golden_cnt = {}
tag2result_cnt = {}
tag2TP_cnt = {}
all_precision = 0
all_recall = 0

tag2golden_cnt[1] = 0

for i in 0..golden_tags.length-1 do
  gt = golden_tags[i]
  rt = result_tags[i]
#  puts gt, rt
  tag2golden_cnt[gt] = tag2golden_cnt[gt].to_i + 1
  tag2result_cnt[rt] = tag2result_cnt[rt].to_i + 1
  tag2TP_cnt[rt] = tag2TP_cnt[rt].to_i + (gt == rt ? 1 : 0)

  # make sure hash cell exists
  tag2TP_cnt[gt] = tag2TP_cnt[gt].to_i + 0
  tag2result_cnt[gt] = tag2result_cnt[gt].to_i + 0
end

all_tp = 0
all_f1 = 0
res_tag2TP_cnt = tag2TP_cnt.sort_by { |key, value| key }
res_tag2TP_cnt.each do |t, tp|
  p = tp.to_f / tag2result_cnt[t]
  r = tp.to_f / tag2golden_cnt[t]
  f1 = 2*p*r / (p+r)
  puts "Class #{t} P, R, F1:  #{p.round(4)} (#{tp}/#{tag2result_cnt[t]}),  #{r.round(4)} (#{tp}/#{tag2golden_cnt[t]}),  #{f1.round(4)}"
  all_precision += p
  all_recall += r
  all_tp += tp
  all_f1 += f1
end

all_rt = 0
tag2result_cnt.each { |tag, rt|
  all_rt += rt
}

all_gt = 0
tag2golden_cnt.each { |tag, gt|
  all_gt += gt
}

micro_avg_precision = all_tp.to_f / all_rt.to_f
micro_avg_recall = all_tp.to_f / all_gt.to_f
micro_avg_f1 = 2*micro_avg_precision*micro_avg_recall / (micro_avg_precision+micro_avg_recall)

puts "Micro P, R, F1:  #{micro_avg_precision.round(4)} (#{all_tp}/#{all_rt}),  #{micro_avg_recall.round(4)} (#{all_tp}/#{all_gt}),  #{micro_avg_f1.round(4)}"
if tag2TP_cnt.size > 0
  macro_avg_precision = all_precision / tag2TP_cnt.size
  macro_avg_recall = all_recall / tag2TP_cnt.size
  macro_avg_f1 = all_f1 / tag2TP_cnt.size
  
  puts "Macro P, R, F1:  #{macro_avg_precision.round(4)},  #{macro_avg_recall.round(4)},  #{macro_avg_f1.round(4)}"
end
